/*Задано N точек на плоскости.
Указать (N-1)-звенную несамопересекающуюся замкнутую ломаную, проходящую через все эти точки.
Предполагается, что никакие три точки не лежат на одной прямой.
Стройте ломаную от точки, имеющей наименьшую координату x.
Если таких точек несколько, то используйте точку с наименьшей координатой y.
Точки на ломаной расположите в порядке убывания углов лучей от начальной точки до всех остальных точек.
Для сортировки точек реализуйте алгоритм сортировки вставками.*/
#include <iostream>

struct point
{
    int x,y;
};

bool cmptgless(point a, point b, point O) //сравнение угловых коэффициентов прямых OA и OB
{
    return (double(a.y - O.y)/double(a.x - O.x) < double(b.y - O.y)/double(b.x - O.x));
}

bool cmpless(point a, point b) //сравнение, какая из точек находится левее, а при равенстве x ниже.
{
    return (a.x < b.x || a.x == b.x && a.y < b.y);
}

void sort(point* a, int n) //сортировка массива точек вставками без модификаций
{
    for(int i = 2; i < n; i++) //начинаем с 2, т.к. 1ый элемент по умолчанию - самая левая нижняя точка и не должен сортироваться
    {
        int j = i - 1;
        while (j >= 1 && cmptgless(a[j], a[j + 1], a[0]))
            {
                std::swap(a[j], a[j + 1]);
                j--;
            }
    }
}

void solve(point* a, int n)
{
    int O = 0; //в O поместим номер самой левой нижней точки
    for(int i = 1; i < n; i++)
        if (cmpless(a[i], a[O]))
            O = i;
    std::swap(a[O], a[0]);
    sort(a, n);
}

int main()
{
    int n;
    std::cin >> n;
    point* a = new point[n];
    for(int i = 0; i < n; i++)
        std::cin >> a[i].x >> a[i].y;
    solve(a,n);
    for(int i = 0; i < n; i++)
        std::cout << a[i].x << ' ' << a[i].y << '\n';
    delete[] a;
    return 0;
}
